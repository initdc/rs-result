module Rs
  # https://doc.rust-lang.org/std/option/index.html
  # https://doc.rust-lang.org/std/option/enum.Option.html
  # https://doc.rust-lang.org/src/core/option.rs.html
  class Option[V]
    class TypeError[V] < StandardError
      def initialize: (T[V] value_type) -> void
    end

    class TypeNilClass < StandardError
    end

    class TypeMismatch < StandardError
    end

    class WrapNil < StandardError
    end

    class UnwrapNone < StandardError
    end

    def is_some: () -> bool

    def is_some_and: () { (V) -> bool } -> bool

    def is_none: () -> bool

    def is_none_or: () { (V) -> bool } -> bool

    def expect: (String msg) -> V

    def unwrap: () -> V

    def unwrap_or: (V default) -> V

    def unwrap_or_else: () { () -> V } -> V

    def map: [U] (T[U] value_type) { (V) -> U } -> Option[U]

    def tap: () { (V) -> bool } -> self

    def map_or: [U] (U default) { (V) -> U } -> U

    # work
    # type int_or_string = Integer | String
    # 
    # not work
    # type ld = lambda { () -> U }
    # type ld = lambda { -> U }
    # type pd = Proc(U)
    # 
    # want, crystal like
    # type D = -> U
    # type F = (V) -> U
    # type F = V -> U
    def map_or_else: [U] (Proc default) { (V) -> U } -> U

    def ok_or: [E] (E error) -> Rs::Result[V, E]

    def ok_or_else: [E] () { () -> E } -> Rs::Result[V, E]

    def and: [U] (Option[U] other) -> Option[U]

    def and_then: [U] (T[U] value_type) { (V) -> Option[U] } -> Option[U]

    def select: () { (V) -> bool } -> bool

    def or: (self other) -> self

    def or_else: () { () -> self } -> self

    def xor: (self other) -> self

    def self.from: [V] (T[V] value_type) { () -> V } -> self

    def self.from?: [V] (T[V] value_type) { () -> V? } -> self

    def self.from!: [V] (T[V] value_type) { () -> V } -> self
  end
end

class Some[V] < Rs::Option[V]
  @value: V

  # wanted Class[V]
  @value_type: T[V]

  attr_reader value_type: T[V]

  def self.[]: [V] (T[V] value_type) { () -> V } -> self

  def inspect: () -> ::String

  def ==: (Rs::Option[V] other) -> bool

  def initialize: (V value) -> void
end

class None[V] < Rs::Option[V]
  @value_type: T[V]

  attr_reader value_type: T[V]

  def self.[]: [V] (T[V] value_type) -> self

  def inspect: () -> ::String

  def ==: (Rs::Option[V] other) -> bool

  def initialize: (?T[V] value_type) -> void
end
