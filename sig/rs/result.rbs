module Rs
  # https://doc.rust-lang.org/std/result/index.html
  # https://doc.rust-lang.org/std/result/enum.Result.html
  # https://doc.rust-lang.org/src/core/result.rs.html
  class Result[V, E]
    VERSION: String

    class TypeError < StandardError
      def initialize: [V, E] (T[V] value_type, T[E] error_type) -> void
    end

    class TypeNilClass < StandardError
    end

    class TypeMismatch < StandardError
    end

    class WrapNil < StandardError
    end

    class UnwrapOnErr < StandardError
    end

    class UnwrapErrOnOk < StandardError
    end

    def is_ok: () -> bool

    def is_ok_and: () { (V) -> bool } -> bool

    def is_err: () -> bool

    def is_err_and: () { (E) -> bool } -> bool

    def ok: () -> Rs::Option[V]

    def err: () -> Rs::Option[E]

    def map: [U] (T[U] value_type) { (V) -> U } -> Result[U, E]

    def map_or: [U] (U default) { (V) -> U } -> U

    def map_or_else: [U] (Proc default) { (V) -> U } -> U

    def map_err: [F] (T[F] error_type) { (E) -> F } -> Result[V, F]

    def tap: () { (V) -> void } -> self

    def tap_err: () { (E) -> void } -> self

    def expect: (String msg) -> V

    def unwrap: () -> V

    def expect_err: (String msg) -> E

    def unwrap_err: () -> E

    def and: [U] (Result[U, E] other) -> Result[U, E]

    def and_then: [U] (T[U] value_type) { (V) -> Result[U, E] } -> Result[U, E]

    def or: [F] (Result[V, F] other) -> Result[V, F]

    def or_else: [F] (T[F] error_type) { (E) -> Result[V, F] } -> Result[V, F]

    def unwrap_or: (V default) -> V

    def unwrap_or_else: () { (E) -> V } -> V

    # type res_init = [V, E] (T[V], E) { () -> V } -> Result[V, E]
    def self.from_or: [V, E] (T[V] value_type, E error) { () -> V } -> self

    def self.from_or?: [V, E] (T[V] value_type, E error) { () -> V? } -> self

    def self.from_or!: [V, E] (T[V] value_type, E error) { () -> V } -> self
  end
end

class Ok[V, E] < Rs::Result[V, E]
  @value: V

  @value_type: T[V]

  @error_type: T[E]

  attr_accessor value_type: T[V]

  attr_accessor error_type: T[E]

  def self.[]: [V, E] (T[V] value_type, E error) { () -> V } -> self

  def inspect: () -> ::String

  def ==: (Rs::Result[V, E] other) -> Rs::Result[V, E]

  def initialize: (V value) -> void
end

class Err[V, E] < Rs::Result[V, E]
  @error: E

  @error_type: T[E]

  @value_type: T[V]

  attr_accessor value_type: T[V]

  attr_accessor error_type: T[E]

  def self.[]: [V, E] (T[V] value_type, E error) { () -> E } -> self

  def inspect: () -> ::String

  def ==: (Rs::Result[V, E] other) -> Rs::Result[V, E]

  def initialize: (E error) -> void
end
